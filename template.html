<!--
Google IO 2012 HTML5 Slide Template
GREE Technology Conference 2013.

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mah√© <lukem@google.com>
          Jason Parrott <jason.parrott@gree.net>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>GREE Technology Conference 2013</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

  <slide class="logoslide nobackground">
    <article class="box vcenter">
      <span><img src="images/gree_techconference_logo.png"></span>
    </article>
  </slide>

  <slide class="title-slide segue nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Performance</h2>
      <h3>What is it?</h3>
    </hgroup>
  </slide>

  <slide class="segue quote">
    <article class="box vcenter auto-fadein smaller">
      <q>The act of performing; carrying into execution or action; execution; achievement; accomplishment; representation by action; as, the performance of an undertaking of a duty.</q>
      <div class="author">
        http://en.wiktionary.org/wiki/performance
      </div>
    </article>
  </slide>

  <slide class="segue quote">
    <article class="box vcenter auto-fadein smaller">
      <q>Doing something that has a result.</q>
      <div class="author">
        Jason Parrott (Me)
      </div>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Performance</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Too general</li>
        <li>Let's focus on this definition...</li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Performance</h2>
      <h3>Final definition</h3>
    </hgroup>
    <article class="small">
      <pre class="prettyprint" data-lang="javascript">
        var doingSomething = 'Displaying a web page';
        var result = 'speed';

        var performance = doingSomething + ' with _adjective_' + result;

        function performanceDefinition(adjective) {
          console.log(
            performance.replace(/_adjective_/g, adjective ? adjective + ' ' : '')
          );
        }

        performanceDefinition();
        <span data-highlight>// &gt; "Displaying a web page with speed"</span>
      </pre>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Performance</h2>
      <h3>What we will focus on</h3>
    </hgroup>
    <article class="small">
      <pre class="prettyprint" data-lang="javascript">
        var i, il;
        var types = [
          'awesome', 'good', 'bad', 'terrible'
        ];

        for (i = 0, il = types.length; i &lt; il; i++) {
          performanceDefinition(types[i]);
        }

        <span data-highlight>// &gt; "Displaying a web page with awesome speed"</span>
        // &gt; "Displaying a web page with good speed"
        // &gt; "Displaying a web page with bad speed"
        // &gt; "Displaying a web page with terrible speed"
      </pre>
    </article>
  </slide>
<!-- 7 -->
  <slide class="segue dark nobackground">
    <aside class="note">
      <b>14:23</b>
    </aside>
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Performance</h2>
      <h3>Types of performance on the web</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Types of Performance on the Web</h2>
    </hgroup>
    <article>
      <div class="columns">
        <ul>
          <h3>HTML</h3>
          <li>Network</li>
          <li>Resource</li>
          <li>Parsing</li>
          <li data-highlight>Layout</li>
          <li data-highlight>Painting</li>
          <li data-highlight>Compositing</li>
        </ul>
        <ul>
          <h3>JavaScript</h3>
          <li>Raw execution</li>
          <li data-highlight>Usage of DOM</li>
          <li data-highlight>Canvas</li>
          <li>A million others...</li>
        </ul>
      </div>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Layout</h2>
      <h3>In other words, reflow</h3>
    </hgroup>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Calculation of element's position and size</li>
        <li>Many kind of layouts, each with their own algorithms</li>
        <li>The old ones' specifications are ugly and difficult to understand</li>
        <li>Yes, there is a CSS3 Positioning Module. But nobody implements it?</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Layout</h2>
      <h3>What is it?</h3>
    </hgroup>
    <article>
      <ul>
        <li>Calculation of element's position and size</li>
        <li>Many different layout models</li>
        <li>Messy and hidden inside of the CSS2 specification
          <ul>
            <li><a href="http://www.w3.org/TR/CSS2/visudet.html">http://www.w3.org/TR/CSS2/visudet.html</a></li>
          </ul>
        </li>
        <li>New layout models that are very clear and easy to understand.
          <ul>
            <li><a href="http://www.w3.org/TR/css3-flexbox/">Flexbox</a> (http://www.w3.org/TR/css3-flexbox/)</li>
            <li><a href="http://www.w3.org/TR/css3-multicol/">Multi-column</a> (http://www.w3.org/TR/css3-multicol/)</li>
            <li><a href="http://www.w3.org/TR/css3-grid-layout/">Grid</a> (http://www.w3.org/TR/css3-grid-layout/)</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>That's a lot of things calculate and we want to make this process as fast as possible</li>
        <li>Calculating the position of thousands of nodes WILL be slow</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Layout</h2>
      <h3>Why do we care?</h3>
    </hgroup>
    <article>
      <ul>
        <li>Most average web sites have huge numbers of nodes to layout</li>
        <li>Yahoo.co.jp had 2153 nodes (text and elements) (And that's optimized!)</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Layout</h2>
      <h3>How Positioning Works</h3>
    </hgroup>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>We will ignore new and unstable layout models like flexbox</li>
      </ul>
    </aside>
    <hgroup>
      <h2>How Positioning Works</h2>
      <h3>Types of Positioning</h3>
    </hgroup>
    <article>
      <ul>
        <li>Normal Flow
          <ul>
            <li><code>position: static</code></li>
            <li><code>position: relative</code></li>
          </ul>
        </li>
        <li>Floating (<code>float: left/right</code>)</li>
        <li>Absolute
          <ul>
            <li><code>position: absolute</code></li>
            <li><code>position: fixed</code></li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Normal Flow</h2>
      <h3>Static</h3>
    </hgroup>
    <article>
      <ul>
        <li>The simplest</li>
        <li>Create boxes for containers (like div)</li>
        <li>Flow the boxes vertically, one box per row</li>
        <li>Flow content (line-boxes) horizontally inside boxes</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>All relative layouts first do static. Therefore relative is always slower than static (slightly)</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Normal Flow</h2>
      <h3>Relative</h3>
    </hgroup>
    <article>
      <ul>
        <li>Move from normal position by x,y</li>
        <li><b>All</b> relative layouts first do a static layout</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>If all floats, will be fast.</li>
        <li>If mixed with normal flow elements, its slower due to complexity</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Floating</h2>
    </hgroup>
    <article>
      <ul>
        <li>Positions elements on the left or right side of another float element or the current block container</li>
        <li>Very difficult to plan and understand</li>
        <li>Can be slow or fast</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Containing block is the viewport or an element with position not equal to static</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Absolute</h2>
      <h3>Absolute absolute</h3>
    </hgroup>
    <article>
      <ul>
        <li>Positions elements relative to the current containing block, in CSS units, to an exact location</li>
        <li>Messy if not managed properly</li>
        <li>Layout is <b>fast</b></li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Since we are relative to something that never changes, scrolling never happens</li>
        <li>However there are issues on mobile devices...</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Absolute</h2>
      <h3>Fixed absolute</h3>
    </hgroup>
    <article>
      <ul>
        <li>A subclass of regular absolute</li>
        <li>Always positions relative to the viewport (screen)</li>
        <li>Layout is <b>very</b> fast</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Layout</h2>
      <h3>Positioning Tips</h3>
    </hgroup>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Fixed > absolute > static > relative > float</li>
        <li>Things get slower because deep in the tree, if you edit something that affects something high in the tree, the whole tree might have to be reflowed</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Order of Speed</h2>
    </hgroup>
    <article>
      <ul>
        <li>Fixed > absolute > static > relative > float</li>
        <li>Float <b>can</b> be faster or slower</li>
        <li>As you go deep in the DOM tree, static, relative and float get slower</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>It just creates new containing blocks that just use up resources</li>
        <li>I see this often in web sites. CSS-wise its convenient to make simple classes like this but it hurts performance a lot</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Relative Positioning Evil</h2>
    </hgroup>
    <article class="small">
      <ul>
        <li>Don't use <code>position:relative</code> if you don't need to</li>
      </ul>
      <pre class="prettyprint" data-lang="css">
        div { position: relative; }
        .moveable_class { position: absolute; !important }
      </pre>
      <pre class="prettyprint" data-lang="html">
        &lt;div&gt;Hello&lt;/div&gt;
        &lt;div&gt;world!&lt;/div&gt;
        &lt;div&gt;How are you today?&lt;/div&gt;
        <b>&lt;div&gt;</b>
          <b>&lt;div class="moveable_class" style="left: 34px; top: 50px"&gt;Dandy&lt;/div&gt;</b>
        <b>&lt;/div&gt;</b>
        &lt;div&gt;:)&lt;/div&gt;
      </pre>
    </article>
  </slide>
<!-- 23 -->
  <slide class="segue dark nobackground">
    <aside class="note">
      <b>14:31</b>
    </aside>
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Layout</h2>
      <h3>With JavaScript</h3>
    </hgroup>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>First of all, I love JavaScript</li>
      </ul>
    </aside>
    <hgroup>
      <h2>JavaScript is Scary</h2>
    </hgroup>
    <article class="build">
      <ul>
        <li>JavaScript allows you to do cool stuff</li>
        <li>It also allows you to do something evil</li>
      </ul>
      <pre class="prettyprint smaller" data-lang="javascript">
        function HTMLHtmlElement() {
          Object.defineProperty(this, 'offsetWidth', {
            <b>get: function() {</b>
              <b>// Calculate all child elements' positions and sizes!</b>
            <b>},</b>
            configurable: false,
            enumerable: true
          });
        }

        var element = new HTMLHtmlElement();
        for (var i = 0; i &lt; 10000; i++) { console.log(element.offsetWidth) }
      </pre>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Offset and Client Properties</h2>
      <h3>Question</h3>
    </hgroup>
    <article>
      <div class="columns">
        <ul>
          <li>offsetTop</li>
          <li>offsetLeft</li>
          <li>offsetWidth</li>
          <li>offsetHeight</li>
        </ul>
        <ul>
          <li>clientTop</li>
          <li>clientLeft</li>
          <li>clientWidth</li>
          <li>clientHeight</li>
        </ul>
      </div>
      <p>Which of the above properties cause a lot of calculations do happen in the background?</p>
      <a style="font-size:.7em" href="http://www.w3.org/TR/cssom-view/">http://www.w3.org/TR/cssom-view/</a>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Offset and Client Properties</h2>
      <h3>Answer</h3>
    </hgroup>
    <article>
      <p>All of them</p>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>This is a very heavy process</li>
        <li>How heavy?</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Offset and Client Properties</h2>
    </hgroup>
    <article>
      <p>These properties all calculate their own size (padding edge or border edge).</p>
      <p>All of their children's sizes are also be calculated.</p>
    </article>
  </slide>

  <slide class="">
    <article class="box vcenter">
      <a style="font-size:2em" href="http://jsperf.com/offsetwidth">http://jsperf.com/offsetwidth</a>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Offset and Client Properties</h2>
    </hgroup>
    <article>
      <ul>
        <li>If you know the value won't change, cache it and use it</li>
        <li>If you access them in the middle of changing other properties, it is possible to force a reflow</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Inserting Elements Via the DOM</h2>
    </hgroup>
    <article>
      <ul>
        <li>A common thing to do since the DHTML days</li>
      </ul>
      <pre class="prettyprint" data-lang="javascript">
        var element, body = document.body;
        for (var i = 0; i &lt; 500; i++) {
          element = document.createElement('div');
          body.appendChild(element);
          element.style.width = element.style.height = '40px';
        }
      </pre>
      <ul class="build">
        <li>There are a couple things you should <b>not</b> do here</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Inserting Elements Via the DOM</h2>
    </hgroup>
    <article>
      <pre class="prettyprint" data-lang="javascript">
        var element, body = document.body;
        <b>var fragment = document.createDocumentFragment();</b>
        for (var i = 0; i &lt; 500; i++) {
          element = document.createElement('div');
          <b>element.style.width = element.style.height = '40px';</b>
          <b>fragment.appendChild(element);</b>
        }
        <b>body.appendChild(fragment);</b>
      </pre>
      <ul>
        <li>Edit all properties <b>before</b> calling appendChild</li>
        <li>Use a DocumentFragment (<a href="http://dom.spec.whatwg.org/#interface-documentfragment">http://dom.spec.whatwg.org/#interface-documentfragment</a>)</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>DocumentFragment</h2>
      <h3>Some interesting facts</h3>
    </hgroup>
    <article>
      <ul>
        <li>They used to be <b>way</b> faster than anything else</li>
        <li>With recent optimizations in browsers, they are roughly the same speed as the normal appendChild</li>
        <li>Elements inside a DocumentFragment have no layout box
          <ul>
            <li>Almost all values in CSS are <b>uninitialized or 0</b>
              <ul>
                <li>Try it out with window.getComputedStyle!</li>
              </ul>
            </li>
            <li>Impossible to make a reflow or paint happen</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>I'll explain GPU mode later</li>
        <li>Browsers are optimized so that they are smart about when reflows fire</li>
        <li>Meaning we don't need to worry about this as much as before, but in some cases is good to use</li>
      </ul>
    </aside>
    <hgroup>
      <h2>The Remove/Re-add Rule</h2>
    </hgroup>
    <article>
      <p>There are many articles on the Internet saying that it is faster to remove the group of nodes you are about to edit from the DOM tree (removeChild), edit all the nodes (avoiding reflow), and re-insert them back in to the same place in the DOM tree.</p>
      <ul>
        <li>This used to be true and still is in some cases</li>
        <li>It is now <b>false</b> in all situations that <b>I have personally tested</b> that <b>use GPU mode for rendering</b>
          <ul>
            <li>Like transform: translate3d(x,y,z)</li>
            <li>Now-a-days, the browser will get <b>slower</b> due to a <b>paint</b> that occurs from re-adding the nodes</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Layout</h2>
      <h3>Results</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Layout</h2>
      <h3>Results</h3>
    </hgroup>
    <article>
      <ul>
        <li>Fixed > absolute > static > relative > float</li>
        <li><b>Remember</b> JavaScript properties can be slow <b>just by accessing them</b></li>
        <li><b>Cache</b> computed values if possible</li>
        <li>Edit element properties <b>before</b> adding them</li>
        <li><b>Use</b> DocumentFragment</li>
        <li><b>Do not use</b> the Remove/Re-add Rule in GPU mode</li>
      </ul>
    </article>
  </slide>
<!-- 36 -->
  <slide class="segue dark nobackground">
    <aside class="note">
      <b>14:39</b>
    </aside>
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Painting</h2>
      <h3>How the browser draws</h3>
    </hgroup>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Painting methods (and performance) change drastically from platform to platform and browser to browser</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Painting</h2>
      <h3>What is is?</h3>
    </hgroup>
    <article>
      <ul>
        <li>After layout, browsers need to <b>draw</b> elements to the screen</li>
        <li>Chrome/WebKit calls this painting</li>
        <li>Calculates what elements are visible now and draw them</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>For the decendant, its possible that a change will cause a redraw for background and borders and such for the parent</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Painting</h2>
      <h3>When it happens</h3>
    </hgroup>
    <article>
      <ul>
        <li>Viewing (loading) the page the first time</li>
        <li>Scrolling the page</li>
        <li>Hiding an element and re-showing it again in GPU mode</li>
        <li>Changing visual properties of an element</li>
        <li>Possibily when a decendant (or possibly ancestor) element changes</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Can't really optimize it too much. Just be thinking about it. Here's how.</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Painting</h2>
      <h3>Seeing when it happens</h3>
    </hgroup>
    <article>
      <ul>
        <li>In Chrome, open up the developer tools</li>
        <li>Switch to the <b>Timeline</b> panel</li>
        <li>Hit the record button at the bottom</li>
        <li>Play with your web site</li>
        <li>Return to the developer tools and hit the record button again to stop recording</li>
        <li>Look at the data!</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Explain the paint events and show off layout too</li>
        <li>Remember the MS seconds!</li>
      </ul>
    </aside>
    <article>
      <iframe src="sample_layout_topleft.html"></iframe>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Painting</h2>
      <h3>Some fun</h3>
    </hgroup>
    <article style="font-size:0.7em;">
      <p>Let's see what happens when we try out the Remove/Re-add Rule!</p>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Remember the time and compare.</li>
        <li>If there is time, show the paint events</li>
      </ul>
    </aside>
    <article>
      <iframe src="sample_layout_halfmyth_lefttop.html"></iframe>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Painting</h2>
      <h3>Results</h3>
    </hgroup>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Shadow related CSS (and canvas) is very slow due to the calculations of shadows (especially blur)</li>
        <li>Also slow because you paint over top of OTHER elements outside of your layout</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Painting</h2>
      <h3>Results</h3>
    </hgroup>
    <article>
      <ul>
        <li>Painting is difficult to optimize</li>
        <li>Check the developer tools timeline feature</li>
        <li>Avoid shadow related CSS</li>
      </ul>
    </article>
  </slide>
<!-- 45 -->
  <slide class="segue dark nobackground">
    <aside class="note">
      <b>14:47</b>
    </aside>
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Compositing</h2>
      <h3>Mixing everything together</h3>
    </hgroup>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Layout layers are like the different types of positions and DOM node order</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Compositing</h2>
      <h3>What is it?</h3>
    </hgroup>
    <article>
      <ul>
        <li>Taking painted elements and mixing them in the correct order on the screen</li>
        <li>Mostly a GPU thing</li>
        <li>Looks at information like z-index, transform's Z properties, opacity and layout layers</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Painting will not happen if only position related properties changed</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Compositing</h2>
      <h3>When it happens</h3>
    </hgroup>
    <article>
      <ul>
        <li>After a paint</li>
        <li>After position-related properties change on an element</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Compositing</h2>
      <h3>GPU mode</h3>
    </hgroup>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>3D API's <b>need</b> to only work with polygons, points and textures
          <ul>
            <li>Ok, so shaders are there too, but we will ignore those as things will get too complex</li>
          </ul>
        </li>
      </ul>
    </aside>
    <hgroup>
      <h2>GPU mode</h2>
      <h3>What is it?</h3>
    </hgroup>
    <article>
      <ul>
        <li>A method to render everything to the screen</li>
        <li>Usage of 3D APIs (OpenGL, DirectX, etc) for <b>everything</b></li>
        <li>In GPU mode, browsers translate a web page in to a 3D scene!</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>GPU mode</h2>
      <h3>When is it used?</h3>
    </hgroup>
    <article>
      <ul>
        <li>Using a 3D related CSS property</li>
        <li>Using HTML Canvas in a modern browser</li>
        <li>Depending on platform and browser flags, <b>always</b></li>
        <li>In the future, probably always!</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Certain mobile devices by manufacturers that like to tweek things in a bad way create bugs in the GPU mode rendering pipeline that are impossible to avoid</li>
      </ul>
    </aside>
    <hgroup>
      <h2>GPU mode</h2>
      <h3>So?</h3>
    </hgroup>
    <article>
      <ul>
        <li>Every element is at least a single rectangle with a texture applied to it (CSS style)</li>
        <li>It should <b>always</b> be used if possible</li>
        <li>Unless you hit some of GPU mode's weaknesses...</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>GPU mode</h2>
      <h3>Annoying fun!</h3>
    </hgroup>
    <article style="font-size:0.5em;">
      <p>The Remove/Re-add Rule and GPU mode with <code>transform: translate3d</code> instead of left and top!</p>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Show the paints and explain the remove-re-add rule again</li>
        <li>Currently, Chrome will <b>unload</b> textures from memory when removed from the DOM</li>
        <li>In the Remove/Re-add Rule, <b>all</b> elements' textures are destroyed</li>
        <li>I see this as something that can be optimized in the future and expect developers of browsers to fix this</li>
        <li>But for now, be mindful that when animating/positioning things via GPU mode, you are working with low level textures and need to think like that</li>
      </ul>
    </aside>
    <article>
      <iframe src="sample_layout_halfmyth_translate3d.html"></iframe>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>GPU mode</h2>
      <h3>Annoying fun fixed!</h3>
    </hgroup>
    <article style="font-size:0.7em;">
      <p>Without the Remove/Re-add Rule with translate3d!</p>
    </article>
  </slide>

  <slide class="">
    <article>
      <iframe src="sample_layout_translate3d.html"></iframe>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Compositing</h2>
      <h3>Results</h3>
    </hgroup>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Image objects are textures - Be mindful of memory</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Compositing</h2>
      <h3>Results</h3>
    </hgroup>
    <article>
      <ul>
        <li><b>Use</b> GPU mode if possible</li>
        <li><b>Imagine</b> all objects are textures in memory</li>
        <li><b>Test</b> for devices that have bugs in GPU mode</li>
        <li><b>Do not use</b> the Remove/Re-add Rule in GPU mode</li>
        <li><b>Remember</b> that textures are <b>destroyed</b> when their element is removed from the DOM</li>
      </ul>
    </article>
  </slide>
<!-- 59 -->
  <slide class="segue dark nobackground">
    <aside class="note">
      <b>14:55</b>
    </aside>
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>HTML Canvas</h2>
      <h3>2D is actually 3D</h3>
    </hgroup>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Talk about how modern web sites use Canvas for special effects on their sites</li>
      </ul>
    </aside>
    <hgroup>
      <h2>HTML Canvas</h2>
      <h3>What is it?</h3>
    </hgroup>
    <article>
      <ul>
        <li>An element for drawing</li>
        <li>Provides 2D and 3D API's (Canvas and WebGL)</li>
        <li>Useful for games and interesting web sites</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Drawing pixels is very slow in software. So browsers try very hard now-a-days to make Canvas as fast as possible with amazing optimizations</li>
      </ul>
    </aside>
    <hgroup>
      <h2>HTML Canvas</h2>
      <h3>How it works</h3>
    </hgroup>
    <article>
      <ul>
        <li>A simple implementation would directly draw pixels as you do commands</li>
        <li>Drawing pixels is slow</li>
        <li>Instead amazing technologies exist to speed things up</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>First of all, this means GPU mode
          <ul>
            <li>Remember, everything is a texture, polygon or point</li>
            <li>Have a 500x500 real pixel Canvas? You have a 500x500 pixel texture sitting in the GPU</li>
          </ul>
        </li>
        <li>Even though you think you are drawing in 2D, you are actually drawing in 3D</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Accelerated Canvas</h2>
    </hgroup>
    <article>
      <ul>
        <li>GPU mode</li>
        <li>Canvases exist as a <b>texture</b> in the GPU</li>
        <li>Canvas commands get <b>translated</b> in to some 3D command to be run on the GPU</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Accelerated Canvas</h2>
    </hgroup>
    <article>
      <ul>
        <li>Imagine fillRect(x, y, w, h) being a rect polygon filled with the current fillStyle colour and/or pattern texture</li>
        <li>Transforming paths and images is very fast</li>
        <li>Drawing paths is not <b>awesomely</b> fast</li>
        <li>drawImage <b>is awesomely fast</b></li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>Executes them when that canvas is used</li>
        <li>For example when if you draw in to a Canvas element not in the DOM tree, it will never actually draw anything to the canvas until you call toDataURL, getImageData, or drawImage it to another Canvas</li>
      </ul>
    </aside>
    <hgroup>
      <h2>Deferred Canvas</h2>
    </hgroup>
    <article>
      <ul>
        <li>Chrome optimization for Canvas called deferred 2d Canvas</li>
        <li>Takes GPU commands from accelerated Canvas and <b>waits</b> to execute them</li>
        <li>Executes them when that canvas is <b>used</b></li>
        <li>Many optimizations like merging drawing commands together possible</li>
        <li>Transparent to the developer!</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <aside class="note">
      <ul>
        <li>GPU's are made for rendering textures FAST. That is what drawImage does</li>
      </ul>
    </aside>
    <hgroup>
      <h2>drawImage</h2>
    </hgroup>
    <article>
      <ul>
        <li>No reason <b>not</b> to use drawImage</li>
        <li>Literally copying pixels directly in the GPU. <b>Can't get any faster</b></li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <article style="font-size:0.6em">
      <p>Use fillStyle and bezierCurveTo each frame to draw all 500 hearts</p>
    </article>
  </slide>

  <slide class="">
    <article>
      <iframe src="sample_layout_canvas_rawdraw.html"></iframe>
    </article>
  </slide>

  <slide class="">
    <article style="font-size:0.6em">
      <p>Cache all 500 hearts as individual Canvases and drawImage them</p>
    </article>
  </slide>

  <slide class="">
    <article>
      <iframe src="sample_layout_canvas_drawimage.html"></iframe>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>HTML Canvas</h2>
      <h3>Results</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>HTML Canvas</h2>
      <h3>Results</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>Modern Canvas is <b>actually 3D</b></li>
        <li>Uses GPU mode</li>
        <li>Transforming paths and images is very fast</li>
        <li>Drawing paths is <b>not as fast</b> as <b>drawImage</b></li>
        <li><b>Always</b> use drawImage</li>
        <li>Browsers are getting <b>smarter</b> and <b>faster</b> every day</li>
      </ul>
    </article>
  </slide>
<!-- 72 -->
  <slide class="">
    <aside class="note">
      <b>15:02</b>
    </aside>
    <hgroup>
      <h2>requestAnimationFrame</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>What about the infamous requestAnimationFrame?</li>
        <li>You should use it in real world projects!</li>
        <li>Allows you to render only when the browser will actually render to the screen</li>
        <li>setTimeout will render faster than what is actually displayed</li>
        <li>Optimized so that render/drawing related operations run <b>faster</b> than in normal execution</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Summary</h2>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Summary</h2>
      <h3>Things we covered</h3>
    </hgroup>
    <article>
      <ul>
        <li>Overview of how to make many parts of the browser faster</li>
        <li>How to make layout a bit faster, especially in JavaScript</li>
        <li>Overview of what painting is and how to debug it for speed</li>
        <li>Overview of what compositing and GPU mode is and how to work with it</li>
        <li>How to use HTML Canvas (2D) a faster</li>
      </ul>
    </article>
  </slide>

  <slide class="thank-you-slide segue nobackground">
    <aside class="gdbar right"><img src="images/gree_logo_small.png"></aside>
    <div>
      <article class="box vleft auto-fadein">
        <h2>Thank You!</h2>
        <p>Contact Information</p>
      </article>
      <p class="auto-fadein" data-config-contact>

      </p>
    </div>
  </slide>

  <slide class="logoslide nobackground">
    <article class="box vcenter">
      <span><img src="images/gree_techconference_logo.png"></span>
    </article>
  </slide>

  <slide class="backdrop"></slide>

</slides>

<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>
