<!--
Google IO 2012 HTML5 Slide Template
GREE Technology Conference 2013.

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mah√© <lukem@google.com>
          Jason Parrott <jason.parrott@gree.net>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>GREE Technology Conference 2013</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

  <slide class="logoslide nobackground">
    <article class="box vcenter">
      <span><img src="images/gree_techconference_logo.png"></span>
    </article>
  </slide>

  <slide class="title-slide segue nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Performance</h2>
      <h3>What is it?</h3>
    </hgroup>
  </slide>

  <slide class="segue quote">
    <article class="box vcenter auto-fadein smaller">
      <q>The act of performing; carrying into execution or action; execution; achievement; accomplishment; representation by action; as, the performance of an undertaking of a duty.</q>
      <div class="author">
        http://en.wiktionary.org/wiki/performance
      </div>
    </article>
  </slide>

  <slide class="segue quote">
    <article class="box vcenter auto-fadein smaller">
      <q>Doing something that has a result.</q>
      <div class="author">
        Jason Parrott (Me)
      </div>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Performance</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Too general</li>
        <li>Let's focus on this definition...</li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Performance</h2>
      <h3>Final definition</h3>
    </hgroup>
    <article class="small">
      <pre class="prettyprint" data-lang="javascript">
        var doingSomething = 'Displaying a web page';
        var result = 'speed';

        var performance = doingSomething + ' with _adjective_' + result;

        function performanceDefinition(adjective) {
          console.log(
            performance.replace(/_adjective_/g, adjective ? adjective + ' ' : '')
          );
        }

        performanceDefinition();
        <span data-highlight>// &gt; "Displaying a web page with speed"</span>
      </pre>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Performance</h2>
      <h3>What we will focus on</h3>
    </hgroup>
    <article class="small">
      <pre class="prettyprint" data-lang="javascript">
        var i, il;
        var types = [
          'awesome', 'good', 'bad', 'terrible'
        ];

        for (i = 0, il = types.length; i &lt; il; i++) {
          performanceDefinition(types[i]);
        }

        <span data-highlight>// &gt; "Displaying a web page with awesome speed"</span>
        // &gt; "Displaying a web page with good speed"
        // &gt; "Displaying a web page with bad speed"
        // &gt; "Displaying a web page with terrible speed"
      </pre>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Performance</h2>
      <h3>Types of performance on the web</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Types of Performance on the Web</h2>
    </hgroup>
    <article>
      <p>Several types of performance that we could look at.</p>
      <div class="columns">
        <ul class="build">
          <h3>HTML</h3>
          <li>Network</li>
          <li>Resource</li>
          <li>Parsing</li>
          <li data-highlight>Layout</li>
          <li data-highlight>Painting</li>
          <li data-highlight>Compositing</li>
        </ul>
        <ul class="build">
          <h3>JavaScript</h3>
          <li>Raw execution</li>
          <li data-highlight>Usage of DOM</li>
          <li data-highlight>Canvas</li>
          <li>A million others...</li>
        </ul>
      </div>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Layout</h2>
      <h3>In other words, reflow</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Layout</h2>
      <h3>What is it?</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>When the position and size of all objects is calculated</li>
        <li>No easy to read single algorithm for 'layout'</li>
        <li>Instead there are layout models that have their own algorithms</li>
        <li>They are all messy and hidden inside of the CSS2 specification
          <ul>
            <li><a href="http://www.w3.org/TR/CSS2/visudet.html">http://www.w3.org/TR/CSS2/visudet.html</a></li>
            <li>Yes, there is a CSS3 Positioning Module. But nobody implements it?</li>
          </ul>
        </li>
        <li>There are extentions adding new layout models that are very clear and easy to understand.
          <ul>
            <li><a href="http://www.w3.org/TR/css3-flexbox/">Flexbox</a> (http://www.w3.org/TR/css3-flexbox/)</li>
            <li><a href="http://www.w3.org/TR/css3-multicol/">Multi-column</a> (http://www.w3.org/TR/css3-multicol/)</li>
            <li><a href="http://www.w3.org/TR/css3-grid-layout/">Grid</a> (http://www.w3.org/TR/css3-grid-layout/)</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Layout</h2>
      <h3>Why do we care?</h3>
    </hgroup>
    <article>
      <ul>
        <li>Load up your average web page and count the number of DOM objects that exist inside it</li>
        <li>Yahoo.co.jp had 2153 nodes (text and elements)</li>
        <li>That's a lot of things calculate and we want to make this process as fast as possible</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Layout</h2>
      <h3>How Positioning Works</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>How Positioning Works</h2>
      <h3>Types of Positioning</h3>
    </hgroup>
    <article>
      <p>Since new things like flexbox is still very new, we will ignore them. Here is what we will look at:</p>
      <ul class="build">
        <li>Normal Flow
          <ul>
            <li>position: static</li>
            <li>position: relative</li>
          </ul>
        </li>
        <li>Floating (float: left/right)</li>
        <li>Absolute
          <ul>
            <li>position: absolute</li>
            <li>position: fixed</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Normal Flow</h2>
      <h3>Static</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>The simplest</li>
        <li>Create boxes for containers (like div)</li>
        <li>Flow the boxes vertically, one box per row</li>
        <li>Flow content (line-boxes) horizontally inside boxes
          <ul>
            <li><aside>Calculating the size of content is semi-complex, but not important for this session</aside></li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Normal Flow</h2>
      <h3>Relative</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>Allows you to move the position of an element by an amount relative to it's normal position</li>
        <li><b>All</b> relative layouts first run the static normal flow layout algorithm</li>
        <li>Therefore relative is slower than static (slightly)</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Floating</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Positions elements on the left or right side of another float element or the current block container</li>
        <li>Removes the element from normal flow, meaning other normal flow elements are unaffected by floating elements</li>
        <li>Very difficult to plan and understand</li>
        <li>Can be slow or fast
          <ul>
            <li>Mixing with non-float elements can be a little heavy on layout</li>
            <li>If overflow is something other than hidden, a strange float could cause other elements to overflow causing the scrollbar to appear in turn causing more position calculations</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Absolute</h2>
      <h3>Absolute absolute</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>Positions elements relative to the current containing block, in CSS units, to an exact location
          <ul class="build">
            <li>Containing block is the viewport, an element with position not equal to static</li>
          </ul>
        </li>
        <li>Messy if not managed properly</li>
        <li>Layout is <b>fast</b></li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Absolute</h2>
      <h3>Fixed absolute</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>A subclass of regular absolute</li>
        <li>Always positions elements relative to the viewport (screen)</li>
        <li>Since we are relative to something that never changes, scrolling never happens</li>
        <li>In other words, layout is <b>very</b> fast</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Layout</h2>
      <h3>Positioning Tips</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Order of Speed</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Fixed > absolute > static > relative > float</li>
        <li>However float <b>can</b> be faster or slower depending on the situation</li>
        <li>The further you go down in to the DOM tree, the slower static, relative and float get</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Relative Positioning Evil</h2>
    </hgroup>
    <article class="small">
      <ul>
        <li>Don't use position:relative if you don't need to</li>
        <li>It just creates new containing blocks that just use up resources</li>
      </ul>
      <pre data-lang="css">
        div { position: relative; }
        .moveable_class { position: absolute; !important }
      </pre>
      <pre class="prettyprint" data-lang="html">
        &lt;div&gt;Hello&lt;/div&gt;
        &lt;div&gt;world!&lt;/div&gt;
        &lt;div&gt;How are you today?&lt;/div&gt;
        <b>&lt;div&gt;</b>
          <b>&lt;div class="moveable_class" style="left: 34px; top: 50px"&gt;Dandy&lt;/div&gt;</b>
        <b>&lt;/div&gt;</b>
        &lt;div&gt;:)&lt;/div&gt;
      </pre>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Floating Evil</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Floating itself is not all that slow</li>
        <li>However it's terribly difficult to read and understand</li>
        <li>As a personal request, don't use it</li>
        <li>^_^</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Layout</h2>
      <h3>With JavaScript</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>JavaScript is Scary</h2>
    </hgroup>
    <article class="build">
      <ul class="build">
        <li>First of all, I love JavaScript</li>
        <li>I allows you to do really cool stuff <b>when you know what you're doing</b></li>
        <li>However, the language allows you to do something evil</li>
      </ul>
      <pre class="prettyprint smaller" data-lang="javascript">
        function HTMLHtmlElement() {
          Object.defineProperty(this, 'offsetWidth', {
            <b>get: function() {
              // Calculate all child elements' positions and sizes!
            },</b>
            configurable: false,
            enumerable: true
          });
        }

        var element = new HTMLHtmlElement();
        for (var i = 0; i &lt; 10000; i++) { console.log(element.offsetWidth) }
      </pre>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Offset and Client Properties</h2>
      <h3>Question</h3>
    </hgroup>
    <article>
      <div class="columns">
        <ul>
          <li>offsetTop</li>
          <li>offsetLeft</li>
          <li>offsetWidth</li>
          <li>offsetHeight</li>
        </ul>
        <ul>
          <li>clientTop</li>
          <li>clientLeft</li>
          <li>clientWidth</li>
          <li>clientHeight</li>
        </ul>
      </div>
      <p>Which of the above properties cause a lot of calculations do happen in the background?</p>
      <a style="font-size:.7em" href="http://www.w3.org/TR/cssom-view/">http://www.w3.org/TR/cssom-view/</a>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Offset and Client Properties</h2>
      <h3>Answer</h3>
    </hgroup>
    <article>
      <p>All of them</p>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Offset and Client Properties</h2>
    </hgroup>
    <article>
      <p>These properties all calculate their own size (padding edge or border edge).</p>
      <p>In order to do this, all of their children's sizes must also be calculated.</p>
      <p>Sadly, this is a very heavy process</p>
      <br>
      <p>How heavy?</p>
    </article>
  </slide>

  <slide class="">
    <article class="box vcenter">
      <a style="font-size:2em" href="http://jsperf.com/offsetwidth">http://jsperf.com/offsetwidth</a>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Offset and Client Properties</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>If you know the value won't change, cache it and use it</li>
        <li>If you access them in the middle of changing other properties, it is possible to force a reflow</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Inserting Elements Via the DOM</h2>
    </hgroup>
    <article class="build">
      <ul>
        <li>A common thing to do since the DHTML days</li>
      </ul>
      <pre class="prettyprint" data-lang="javascript">
        var element, body = document.body;
        for (var i = 0; i &lt; 500; i++) {
          element = document.createElement('div');
          body.appendChild(element);
          element.style.width = element.style.height = '40px';
        }
      </pre>
      <ul class="build">
        <li>There are a couple things you should <b>not</b> do here</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Inserting Elements Via the DOM</h2>
    </hgroup>
    <article>
      <pre class="prettyprint" data-lang="javascript">
        var element, body = document.body;
        <b>var fragment = document.createDocumentFragment();</b>
        for (var i = 0; i &lt; 500; i++) {
          element = document.createElement('div');
          <b>element.style.width = element.style.height = '40px';</b>
          <b>fragment.appendChild(element);</b>
        }
        <b>body.appendChild(fragment);</b>
      </pre>
      <ul class="build">
        <li>Edit all properties <b>before</b> calling appendChild</li>
        <li>Use a DocumentFragment (<a href="http://dom.spec.whatwg.org/#interface-documentfragment">http://dom.spec.whatwg.org/#interface-documentfragment</a>)</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>DocumentFragment</h2>
      <h3>Some interesting facts</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>They used to be <b>way</b> faster than anything else</li>
        <li>With recent optimizations in browsers, they are roughly the same speed as the normal appendChild</li>
        <li>Any element inside a DocumentFragment has no layout box
          <ul>
            <li>This means almost all values in CSS are <b>uninitialized or 0</b>
              <ul>
                <li>Try it out with window.getComputedStyle!</li>
              </ul>
            </li>
            <li>However that is exactly why they are so fast</li>
            <li>Impossible to make a reflow or paint happen with a DocumentFragment</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>The Remove/Re-add Rule</h2>
    </hgroup>
    <article>
      <p>There are many articles on the Internet saying that it is faster to remove the group of nodes you are about to edit from the DOM tree (removeChild), edit all the nodes (avoiding reflow), and re-insert them back in to the same place in the DOM tree.</p>
      <ul class="build">
        <li>This used to be true and still is in some cases</li>
        <li>It is now <b>false</b> in all situations that <b>I have personally tested</b> that <b>use GPU mode for rendering</b>
          <ul>
            <li>Like transform: translate3d(x,y,z)</li>
            <li>Possibly in the future <b>everything</b></li>
            <li>Now-a-days, the browser will get <b>slower</b> due to a <b>paint</b> that occurs from re-adding the nodes</li>
          </ul>
        </li>
        <li>Browsers are optimized so that they are smart about when reflows fire</li>
        <li>Meaning we don't need to worry about this as much as before, but in some cases is good to use</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Layout</h2>
      <h3>Results</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Layout</h2>
      <h3>Results</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>Fixed > absolute > static > relative > float</li>
        <li><b>Remember</b> JavaScript properties can do a lot of work <b>just by accessing them</b></li>
        <li><b>Cache</b> computed values (offset/client properties) if possible</li>
        <li>Edit element properties <b>before</b> adding them to the DOM tree</li>
        <li><b>Use</b> DocumentFragment</li>
        <li><b>Do not use</b> the Remove/Re-add Rule in GPU mode</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Painting</h2>
      <h3>How the browser draws</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Painting</h2>
      <h3>What is is?</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>After the layout of elements, the browser needs to <b>draw</b> them to the screen</li>
        <li>In Chrome/WebKit world this is called painting</li>
        <li>The browser will calculate what elements are visible in the viewport and draw them</li>
        <li>Painting methods (and performance) change drastically from platform to platform and browser to browser</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Painting</h2>
      <h3>When it happens</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>When the page is viewed (loads) the first time</li>
        <li>When you scroll the page</li>
        <li>When you hide an element and re-show it again
          <ul>
            <li>This is the problem when you use the Remove/Re-add Rule</li>
          </ul>
        </li>
        <li>When visual properties of an element changes</li>
        <li>Possibily when a decendant (or possibly ancestor) element changes</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Painting</h2>
      <h3>Seeing when it happens</h3>
    </hgroup>
    <article>
      <ul>
        <li>In Chrome, open up the developer tools</li>
        <li>Switch to the <b>Timeline</b> panel</li>
        <li>Hit the record button at the bottom</li>
        <li>Play with your web site</li>
        <li>Return to the developer tools and hit the record button again to stop recording</li>
        <li>Look at the data!</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <article>
      <iframe src="sample_layout_topleft.html"></iframe>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Painting</h2>
      <h3>Some fun</h3>
    </hgroup>
    <article style="font-size:0.7em;">
      <p>Let's see what happens when we try out the Remove/Re-add Rule!</p>
    </article>
  </slide>

  <slide class="">
    <article>
      <iframe src="sample_layout_halfmyth_lefttop.html"></iframe>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Painting</h2>
      <h3>Results</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Painting</h2>
      <h3>Results</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>Painting is difficult to optimize</li>
        <li>Check the developer tools timeline feature</li>
        <li>Avoid shadow related CSS</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Compositing</h2>
      <h3>Mixing everything together</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Compositing</h2>
      <h3>What is it?</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>When the browser takes painted elements and mixes them in the correct order for you to view</li>
        <li>Mostly a GPU thing</li>
        <li>Looks at information like z-index, transform's Z properties, opacity and layout layers
          <ul>
            <li>Like the different types of positions and DOM order</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Compositing</h2>
      <h3>When it happens</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>Whenever a paint happens</li>
        <li>When position-related properties only change on an element
          <ul>
            <li>In this case, no painting will occur (in GPU mode)</li>
          </ul>
        </li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Compositing</h2>
      <h3>GPU mode</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>GPU mode</h2>
      <h3>What is it?</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>A method the browser uses to render everything to the screen</li>
        <li>Uses 3D APIs (OpenGL, DirectX, etc) for <b>everything</b></li>
        <li>3D API's <b>need</b> to only work with polygons, points and textures
          <ul>
            <li>Ok, so shaders are there too, but we will ignore those as things will get too complex</li>
          </ul>
        </li>
        <li>In GPU mode, browsers translate a web page in to a 3D scene!</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>GPU mode</h2>
      <h3>When is it used?</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>Whenever a 3D related CSS property is used</li>
        <li>Whenever you use HTML Canvas in a modern browser</li>
        <li>Depending on platform and browser flags, <b>always</b></li>
        <li>In the future, probably always!</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>GPU mode</h2>
      <h3>So?</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>So all we care about in this session is that in GPU mode, every element ends up as at least a single rectangle (polygon) with a texture applied to it (CSS style)</li>
        <li>It should <b>always</b> be used if possible as it will always give better performance!</li>
        <li>Or so you'd think</li>
        <li>Certain mobile devices by manufacturers that like to tweek things in a bad way create bugs in the GPU mode rendering pipeline that are impossible to avoid</li>
        <li>Besides that, GPU mode currently has some weaknesses...</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>GPU mode</h2>
      <h3>Annoying fun!</h3>
    </hgroup>
    <article style="font-size:0.5em;">
      <p>Let's see what happens when we try out the Remove/Re-add Rule and mix it with GPU mode rendering by using transform: translate3d instead of left and top!</p>
    </article>
  </slide>

  <slide class="">
    <article>
      <iframe src="sample_layout_halfmyth_translate3d.html"></iframe>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>GPU mode</h2>
      <h3>Annoying fun fixed!</h3>
    </hgroup>
    <article style="font-size:0.7em;">
      <p>Ok, let's do it without the Remove/Re-add Rule with translate3d!</p>
    </article>
  </slide>

  <slide class="">
    <article>
      <iframe src="sample_layout_translate3d.html"></iframe>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>GPU mode</h2>
      <h3>Warnings</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>GPU mode requires textures</li>
        <li>It is a slow process to upload textures to GPU memory</li>
        <li>Currently, Chrome will <b>unload</b> textures from memory the instant they are removed from the DOM tree</li>
        <li>In the Remove/Re-add Rule, <b>all</b> elements' textures are destroyed</li>
        <li>When they are re-added to the tree, they need to be re-painting <b>and</b> re-uploaded to the GPU</li>
        <li>That is why there are so many paints going on in the before sample</li>
        <li>I see this as something that can be optimized in the future and expect developers of browsers to fix this</li>
        <li>But for now, be mindful that when animating/positioning things via GPU mode, you are working with low level textures and need to think like that</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Compositing</h2>
      <h3>Results</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Compositing</h2>
      <h3>Results</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li><b>Use</b> GPU mode if possible</li>
        <li><b>Imagine</b> all objects are textures</li>
        <li><b>Test</b> for devices that have bugs in GPU mode</li>
        <li><b>Do not use</b> the Remove/Re-add Rule in GPU mode</li>
        <li><b>Be careful</b> about memory usage</li>
        <li><b>Remember</b> that textures are <b>destroyed</b> when their element is removed from  the DOM</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>HTML Canvas</h2>
      <h3>2D is actually 3D</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>HTML Canvas</h2>
      <h3>What is it?</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>An element allowing you to <b>draw something</b> somewhere</li>
        <li>Provides 2D and 3D API's via the boring Canvas name and WebGL</li>
        <li>Very useful for games and many other interesting web sites</li>
        <li>In modern browsers, actually doesn't have a '2d' option...</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>HTML Canvas</h2>
      <h3>How it works</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>In a simple unoptimized world, as you call drawImage, lineTo, fillRect and such, it will do just that, copy pixels to the screen (or buffer) as you do things</li>
        <li>Sadly, this is very slow, so browsers try much much harder than that</li>
        <li>We'll talk about modern Chrome and it's accelerated deferred rendering</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Accelerated Canvas</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>First of all, this means GPU mode
          <ul>
            <li>Remember, everything is a texture, polygon or point</li>
            <li>This Canvas and all Canvases are also of GPU mode and exist as a <b>texture</b> in the GPU</li>
            <li>Have a 500x500 real pixel Canvas? You have a 500x500 pixel texture sitting in the GPU</li>
          </ul>
        </li>
        <li>All Canvas commands get <b>translated</b> in to some 3D command to be run on the GPU</li>
        <li>Even though you think you are drawing in 2D, you are actually drawing in 3D</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Accelerated Canvas</h2>
    </hgroup>
    <article>
      <ul>
        <li>This session won't cover exactly how Canvas API's translate to GPU commands</li>
        <li>However you can imagine fillRect(x, y, w, h) as making a rect polygon filled with the current fillStyle colour and/or pattern texture</li>
        <li>Transforming paths and images in an accelerated Canvas is very fast as it is done in the GPU</li>
        <li>While fast, actually drawing paths in the GPU is not <b>awesomely</b> fast</li>
        <li>However, drawImage <b>is awesomely fast</b></li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Deferred Canvas</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Modern Chrome has a newer optimization built in for Canvas called deferred 2d Canvas</li>
        <li>It does what it sounds like, it takes those GPU commands generated from the accelerated Canvas and <b>waits</b> to execute them until later</li>
        <li>It executes them when you actually want to <b>use</b> the result of that render
          <ul>
            <li>For example when if you draw in to a Canvas element not in the DOM tree, it will never actually draw anything to the canvas until you call toDataURL, getImageData, or drawImage it to another Canvas</li>
          </ul>
        </li>
        <li>This allows for many optimizations like merging drawing commands together amongst others</li>
        <li>Transparent to the developer!</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>drawImage</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>No reason to <b>not</b> use drawImage <b>exclusivly</b></li>
        <li>Literally copying pixels directly in the GPU. <b>Can't get any faster</b></li>
        <li>Let's look at an example</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <article style="font-size:0.6em">
      <p>Use fillStyle and bezierCurveTo each frame to draw all 500 hearts</p>
    </article>
  </slide>

  <slide class="">
    <article>
      <iframe src="sample_layout_canvas_rawdraw.html"></iframe>
    </article>
  </slide>

  <slide class="">
    <article style="font-size:0.6em">
      <p>Cache all 500 hearts as invididual Canvases and drawImage them</p>
    </article>
  </slide>

  <slide class="">
    <article>
      <iframe src="sample_layout_canvas_drawimage.html"></iframe>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>HTML Canvas</h2>
      <h3>Results</h3>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>HTML Canvas</h2>
      <h3>Results</h3>
    </hgroup>
    <article>
      <ul class="build">
        <li>Modern Canvas is <b>actually 3D</b></li>
        <li>Uses GPU mode</li>
        <li>Transforming paths and images is very fast</li>
        <li>Drawing raw paths is <b>not as fast</b> as <b>drawImage</b></li>
        <li><b>Always</b> use drawImage for everything</li>
        <li>Browsers are getting <b>smarter</b> and <b>faster</b> every day</li>
      </ul>
    </article>
  </slide>

  <slide class="">
    <hgroup>
      <h2>requestAnimationFrame</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>What about the infamous requestAnimationFrame?</li>
        <li>You should use it in real world projects!</li>
        <li>Allows you to render only when the browser will actually render to the screen</li>
        <li>setTimeout will render faster than what is actually displayed</li>
        <li>Optimized so that render/drawing related operations run <b>faster</b> than in normal execution</li>
      </ul>
    </article>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/gree_logo_small.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Summary</h2>
    </hgroup>
  </slide>

  <slide class="">
    <hgroup>
      <h2>Summary</h2>
      <h3>Things we covered</h3>
    </hgroup>
    <article>
      <ul>
        <li>Overview of how to make many parts of the browser faster</li>
        <li>How to make layout a bit faster, especially in JavaScript</li>
        <li>Overview of what painting is and how to debug it for speed</li>
        <li>Overview of what compositing and GPU mode is and how to work with it</li>
        <li>How to use HTML Canvas (2D) a faster</li>
      </ul>
    </article>
  </slide>

  <slide class="thank-you-slide segue nobackground">
    <aside class="gdbar right"><img src="images/gree_logo_small.png"></aside>
    <div>
      <article class="box vleft auto-fadein">
        <h2>Thank You!</h2>
        <p>Contact Information</p>
      </article>
      <p class="auto-fadein" data-config-contact>

      </p>
    </div>
  </slide>

  <slide class="logoslide nobackground">
    <article class="box vcenter">
      <span><img src="images/gree_techconference_logo.png"></span>
    </article>
  </slide>

  <slide class="backdrop"></slide>

</slides>

<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>
